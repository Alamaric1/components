rem package components.bl

rem /**
rem * PropertiesBasedBusinessComponent
rem *
rem * Implementation of a core properties file based KEY-VALUE business component
rem *
rem * 
rem * @version 1.0
rem */

use ::components/bl/BusinessComponent.bbj::BusinessComponent
use com.basiscomponents.db.DataRow
use com.basiscomponents.db.DataField
use ::bbtranslator.bbj::BBTranslator

use java.util.Locale
use java.lang.String
use java.util.TreeMap
use java.util.Iterator
use java.util.Arrays
use java.util.Collection


class public PropertiesBasedBusinessComponent extends BusinessComponent

    field protected BBjString AtbListMap$ = "attributeListMap" 
    field protected BBjString AtbListProperties$ = "attributeListProperties"
    field protected BBjString AtbListPropertiesFolder$ = "properties"
    field protected BBjString Separator$ = "_"    
    field protected BBjString NoAtbListFoundErrorMessage$ = "No attribute List was found for the given attribute"
    field protected static BBjNamespace Namespace! = BBjAPI().getGlobalNamespace()
    field protected BBjString Attribute$
    
    field private BBjNumber NeedRebuild=0
    field private BBTranslator Translator!
    field private TreeMap GlobalMap!
    field private TreeMap CurrentMap!
    method protected PropertiesBasedBusinessComponent(BBjString atbListProperties$, BBjString atbListPropertiesFolder$, BBjString attribute$, BBjString locale$)
    
        #setAllowFilter(1)
        #setAllowSort(1)
        #setAtbListProperties(atbListProperties$)
        #setAtbListPropertiesFolder(atbListPropertiesFolder$)
        #setLocale(locale$)
        #setAttribute(attribute$) 
        
        #Translator! = BBTranslator.getInstance(#AtbListProperties$, locale$ , "" , #AtbListPropertiesFolder$)
        #GlobalMap! = cast(TreeMap, #Namespace!.getValue(#AtbListMap$,err=*next))
        if #GlobalMap! = null() then
                #GlobalMap! = new TreeMap()
                locale! = #getLocale()
                mapName$ = #Attribute$ + #Separator$ + locale!
                #Namespace!.setValue(#AtbListMap$, #GlobalMap!)
        fi
        
        #CurrentMap! = #getAttributeList()
        
    methodend


    rem /**
    rem * Method size:
    rem * return size of result set
    rem * @return BBjNumber size: the size of the whole result set
    rem */
    method public BBjNumber size()
            if #NeedRebuild >0 then
                #prepareResultSet(0,9999)
            fi
        methodret #getResultSet().size()
        
    methodend

    rem /**
    rem * Method refresh:
    rem * refreshes the data and all connected UI controls
    rem * filters get reset
    rem */
    method public void refresh()

        #refresh(1)

    methodend


    rem /**
    rem * Method refresh:
    rem * refreshes the data and all connected UI controls
    rem * @param: BBjNumber resetFilter: if set to 1, all filters set in UI components will be reset
    rem */
    method public void refresh (BBjNumber resetFilter)
        #NeedRebuild=1
        #super!.refresh(resetFilter)
    methodend


    rem /**
    rem * Method setQueryFilter:
    rem * filters the result set
    rem * @param java.util.HashMap filter!: a hash map that holds the filter information, key is the column, data is a BBjVector holding the values for the filter
    rem */
    method public void setQueryFilter(java.util.HashMap filter!)

        #super!.setQueryFilter(filter!)
        #refresh(0) 
        
    methodend


    rem /**
    rem * Method setFulltextFilter:
    rem * filters the result set
    rem * @param BBjString filter$: the search query 
    rem */
    method public void setFulltextFilter(BBjString filter$)

        rem todo

    methodend

    rem /**
    rem * Method drive:
    rem * called by the controller when a change of the selection occured (from outside)
    rem * @param BBjString var$: the variable that changed
    rem * @param BBjVector selection!: the new selection
    rem */
    method public void drive(BBjString var$, BBjVector selection!)

        rem print "drive ",var$,selection!

        #super!.getControllerFilter().put(var$,selection!)

        #refresh(1)

        #prepareResultSet(0,0)

        if #getResultSet().size()>0 then
            v! = new BBjVector()
            v!.addItem(0)
            #setSelection(v!)
        fi        


    methodend


    rem /**
    rem * Method drive:
    rem * called by the controller when a change of the selection occured (from outside)
    rem * @param BBjString var$: the variable that changed
    rem * @param BBjString selection$: the new selection (one item only)
    rem */
    method public void drive(BBjString var$, BBjString selection$)

        v! = new BBjVector()
        v!.addItem(selection$)
        #super!.getControllerFilter().put(var$,v!)

        #drive(var$,v!)
   
    methodend


    rem /**
    rem * Method resetdrive:
    rem * reset one particular controller filter (set by drive)
    rem * @param BBjString var$: the variable that changed
    rem */
    method public void resetdrive(BBjString var$)

        #super!.getControllerFilter().remove(var$)
        #refresh(1)

    methodend


    rem /**
    rem * Method resetdrive:
    rem * reset all controller filter (set by drive)
    rem */
    method public void resetdrive()

        kf! = #super!.getControllerFilter().clone()
        ks! = kf!.keySet()
        it! = ks!.iterator()
        while it!.hasNext()
            var$=it!.next()
            #super!.getControllerFilter().remove(var$)
        wend
        #refresh(1)

    methodend


    rem /**
    rem * Method setControllerFilterUnlock:
    rem * called to (temporarily) unlock the business component from the UIController driver
    rem * @param BBjString field$: the field to be unlocked
    rem * @param BBjNumber f_unlock: 1=unlock, 0=lock
    rem */
    method public void setControllerFilterUnlock(BBjString field$, BBjNumber f_unlock)

        #super!.setControllerFilterUnlock(field$,f_unlock)

        #refresh(1)

    methodend


    rem /**
    rem * Method setSortOrder:
    rem * set the sort order to one column
    rem * @param BBjString col$: the column name
    rem * @param BBjNumber size: 0=descending, 1=ascending
    rem */
    method public void setSortOrder(BBjString col$,BBjNumber sortAscending)
        
        #setSortField(col$)
        #setSortAscending(sortAscending)
       #refresh(0)
    methodend


    rem /**
    rem * Method prepareResultSet:
    rem * Execute the SQL query and prepare the result set
    rem * @param BBjNumber first: start reading at the "first" row from the record set
    rem * @param BBjNumber last: read to the "last" row from the record set
    rem */
    method public void prepareResultSet(BBjNumber first, BBjNumber last)
        
        if #NeedRebuild = 0 then
            methodret 
        fi
        
        al! = #CurrentMap! 
        tm! = new TreeMap()
        ks! = al!.keySet()
        it! = ks!.iterator()
        
        v! = new BBjVector()
        
        if #getSortAscending() = 1 then
            if #getSortField()="KEY" or #getSortField()="" then
                while it!.hasNext()
                    K$=it!.next()
                    v$ = al!.get(k$)
                    tm!.put(#invert(k$),k$)
                wend
            fi
    
            if #getSortField()="VALUE"  then
                while it!.hasNext()
                    K$=it!.next()
                    v$ = al!.get(k$)
                    tm!.put(#invert(v$+k$),k$)
                wend
            fi        
        else
            if #getSortField()="KEY" or #getSortField()="" then
                while it!.hasNext()
                    K$=it!.next()
                    v$ = al!.get(k$)
                    tm!.put(k$,k$)
                wend
            fi
    
            if #getSortField()="VALUE"  then
                while it!.hasNext()
                    K$=it!.next()
                    v$ = al!.get(k$)
                    tm!.put(v$+k$,k$)
                wend
            fi
        fi
        
        ks! = tm!.keySet()
        it! = ks!.iterator()
        
        v! = new BBjVector()

        qf! = #getQueryFilter()
        if qf! <> null() then 
          keyf!     = qf!.get("KEY")
          valuef!   = qf!.get("VALUE")
        fi

        
        cf! = #getControllerFilter()
        
        
        if cf! <> null() and #getControllerFilterUnlock().size()=0 then 
          keycf!     = cf!.get("KEY")
        fi

        
        while it!.hasNext()
            K$=it!.next()
            k1$ = tm!.get(k$)
            v$=al!.get(k1$)
            
            if valuef!<> null() and valuef!.contains(v$)=0 then continue
            if keycf!<> null() and keycf!.contains(k$)=0 then continue
            if keyf!<> null() and keyf!.contains(k$)=0 then continue
                        
            r! = new DataRow()
            r!.setFieldValue("KEY",k1$)
            r!.setFieldValue("VALUE",v$)
            v!.addItem(r!)
        wend        
        
        #NeedRebuild=0
        #super!.setResultSet(v!)
        
    methodend


    rem /**
    rem * Method getColumnAttributes:
    rem * return a data row holding all column-specific attributes
    rem * override to enrich data by formatting rules
    rem * in derived class, always call attr! = #super!.getColumnAttributes() first
    rem * @return DataRow attributes!: DataRow holding the column-specific attributes
    rem */
    method public DataRow getColumnAttributes()

        declare DataRow attr!
        attr! = new DataRow()
        attr!.setFieldValue("KEY","")
        attr!.setFieldValue("VALUE","")

        methodret attr!

    methodend


    rem /**
    rem * Method getDistinctValues:
    rem * override to return distinct values in a given column of the resultset
    rem * these values are mainly used for filterin purpose
    rem * @param BBjString fieldName$: the column name for which the distinct values are requested
    rem * @return java.util.TreeMap distinct!: the distinct values
    rem */
    method public java.util.TreeMap getDistinctValues(BBjString fieldName$)

          tm! = new TreeMap()
          al! = #CurrentMap!
          ks! = al!.keySet()
          it! = ks!.iterator()
          while it!.hasNext()
            k$=it!.next()
            if fieldName$="KEY" then
                tm!.put(k$,0)
            else
                v$=al!.get(k$)
                tm!.put(v$,0) 
            fi
          wend
          
          methodret tm!
          
    methodend


    rem /**
    rem * Method processRecord:
    rem * enrich each record by formatting rules
    rem * @param DataRow attributes!: record passed into method
    rem * @return DataRow attributes!: record with added formatting and calculated fields
    rem */
    method protected DataRow processRecord(DataRow row!)

        methodret row!

    methodend



    rem editing methods


    rem /**
    rem * Method canDeleteSelectedRecords:
    rem * override to tell UI if delete of the currently selected records is allowed
    rem * @return BBjNumber canDelete: 0=delete not allowed, 1=delete is allowed
    rem */
    method public BBjNumber canDeleteSelectedRecord()

        methodret 0

    methodend


    rem /**
    rem * Method deleteSelectedRecords:
    rem * override to delete the currently selected records
    rem * these values are mainly used for filterin purpose
    rem */
    method public void deleteSelectedRecords()

        throw "denied", 18
        
    methodend

    method public DataRow getNewEntity()
        throw "denied", 18
    methodend


    rem /**
    rem * Method saveRecord
    rem * saves a record within the result set
    rem * @param BBjNumber recno: the record number in the resultset; -1 = new record
    rem * @param java.util.HashMap fields!: the fields
    rem */
    method public void saveRecord(BBjNumber recno, DataRow row!)
        throw "denied", 18
    methodend

    rem /**
    rem * Method saveRecord
    rem * saves a record within the result set
    rem * @param BBjNumber recno: the record number in the resultset; -1 = new record
    rem * @param java.util.HashMap fields!: the fields
    rem */
    method public void saveRecord(BBjNumber recno, java.util.HashMap fields!)
        throw "denied", 18
    methodend


    rem /**
    rem * Method validateRecord
    rem * saves a record within the result set
    rem * @param BBjNumber recno: the record number in the resultset; -1 = new record
    rem * @param java.util.HashMap fields!: the fields
    rem * @return BBjNumber passed: 0= no errors, 1=errors were reported
    rem */
    method public BBjNumber validateRecord(BBjNumber recno, java.util.HashMap fields!)
        throw "denied", 18
    methodend


    rem /**
    rem * Method updateResultsetForSingleRecord
    rem * updates a record within the result set
    rem * @param BBjNumber recno: the record number in the resultset; -1 = new record
    rem */
    method protected void updateResultsetForSingleRecord(BBjNumber recno)
        #broadcastPartialUpdate(recno)
    methodend


    rem /**
    rem * Method setEditedRecord
    rem * set the record number in the resultset of the record that is currently being edited
    rem * @param BBjNumber recno: the record number being edited
    rem */
    method public void setEditedRecord(BBjNumber recno)
    methodend


    rem /**
    rem * Method onSelectionChange:
    rem * called after the selection changed, to notify UI components and UI Controller
    rem */
    method public void onSelectionChange()

        #super!.onSelectionChange()

    methodend

    rem /**
    rem * Method broadcastEdit:
    rem * called by UI to notify the BC about an ongoing edit
    rem * the BC will then draw responsible to notify the softlock controller
    rem * @param BBjString fieldName$: the field name that just was edited
    rem * @param BBjSting newContents$: the new Contents of the field
    rem */
    method public void broadcastEdit(BBjString fieldName$, BBjString newContent$)

        rem noop
        
    methodend

    rem /**
    rem * Method getPrimaryKeySegments:
    rem * return the primary key segments
    rem * @return BBjVector primaryKeySegments!: a BBjVector with the primary key segments
    rem */
    method public BBjVector getPrimaryKeySegments()

        v! = new BBjVector()
        v!.addItem("KEY")
        methodret v!

    methodend

    method public BBjString getPrimaryTable()
        methodret "PROPERTIESTABLE"
    methodend
    
     
    rem /**
    rem  *  Checks in the property File of the given locale for Keys matching to the given attribute. If some keys were found,
    rem  *  then a map will be created in the GlobalNamespace, if it is not already created, 
    rem  *  and the map with the keys matching to the given attribute will be added to it. If no Keys were found then an Exception is thrown.
    rem  * 
    rem  * @param attribute! - The attribute which is searched in the property file for the given locale of the 
    rem  * default locale if it was not found in the given one
    rem  * @param locale -  The locale to identify in which property file the attribute list is going to be searched
    rem  * 
    rem  * @return TreeMap - The map which contains the attribute list matching the given attribute
    rem  * 
    rem  * @throws Error 11 - This Error is thrown if no key was found either in the property file for the given 
    rem  * locale as in the property file for the default locale
    rem  */
    method public TreeMap getAttributeList()

        Declare TreeMap currentMap!
        
        locale! = #getLocale() 
        rem Check if the demanded Map is already cached
        currentMap! = #getMapFromNamespace(#Attribute$ + #Separator$ + locale!)
        if(currentMap! <> null() AND !currentMap!.isEmpty()) then 
            methodret currentMap!
        fi

        rem Get a TreeMap containing all keys matching with the given attribute
        currentMap! = #addToMap(locale!)
      
        rem Check if matching keys were found
        if(currentMap! <> null()) then
            #GlobalMap!.put(mapName$,currentMap!) 
            methodret currentMap!
        fi
        rem Check if the given locale is the default locale
        if(locale! <> "") then
            rem If not then Check if the property file for the default locale contains any matching Keys
        
            rem Check if the demanded Map is already cached
            currentMap! = #getMapFromNamespace(#Attribute$ + #Separator$ + "")
            if(currentMap! <> null() AND !currentMap!.isEmpty()) then 
                methodret currentMap!
            fi
            rem Get a TreeMap containing all keys matching with the given attribute
            currentMap! = #addToMap("" )
            
            
            rem Check if matching keys were found
            if(currentMap! <> null()) then
                rem check if the global map is already inserted to the GlobalNamespace
                #GlobalMap!.put(mapName$, currentMap!) 
                methodret currentMap!
            
            fi        
        fi
        rem Throw an Error when no key was found either in the property file for the given locale as for the default locale 
        throw #NoAtbListFoundErrorMessage$ , 11
    methodend
    
    rem /**
    rem  * Checks if the GlobalNamespace contains the global Map. If so, 
    rem  * then the method checks if the global map contains the required map.
    rem  * If so then the required map will be returned else null()
    rem  * 
    rem  * @param str$ - The Name of the map which contains the required list of attributes
    rem  */
    method private TreeMap getMapFromNamespace(BBjString mapName$)
        
        methodret cast(TreeMap,#GlobalMap!.get(mapName$,err=noop))

        noop:   
        methodret null()
    methodend
    

    
    rem /**
    rem  * Returns the value of the given attribute and the given locale
    rem  * 
    rem  * @param attribute! - The attribute which is going to be searched
    rem  * @param locale! - he locale to identify in which property file the attribute list is going to be searched
    rem  * @param attributeKey! - The key to identify which value should be returned
    rem  * 
    rem  * @return value -  The value for the given attribute
    rem  */
    method public BBjString getAttributeValue(BBjString attributeKey!)
        
            methodret str(#CurrentMap!.get(attributeKey!,err=*next))
            throw "No attribute was found for the given Key", 11 
        
    methodend
    
    rem /**
    rem  * Checks if any key from the property File which is registered in translator object matches the searched Key. 
    rem  * If so, then this key and the corresponding value is added to the created map.
    rem  * 
    rem  * @param attribute! - The attribute which is searched in the property file registered in the translator object
    rem  * @param locale -  The locale to identify in which property file the attribute list is going to be searched
    rem  * @param translator! - The translator to get the translation of the matching keys
    rem  * 
    rem  * @return map! - The TreeMap which contains every Key and value matching to the searched attribute or null() if none was found  
    rem  */
    method private TreeMap addToMap( BBjString locale!)
        Declare TreeMap map!
        Declare Iterator it!
        
        rem Get all keys from the property file for the given locale
        
        collection! = #Translator!.getTranslationBundle().getTranslations(new Locale(locale!)).getKeys()
        rem Get the Iterator for the collection containg all Keys of the property file registered in the translator
        ? collection!
        
        
        it! = cast(Iterator, collection!.iterator())
        while it!.hasNext()
            rem Get the Key
            key! = cast(String, it!.next())
            rem check if the Key matches the searched attribute
            if(key!.matches(#Attribute$ + "_.*")) then
                rem check if the map is already created
                ? key!
                if(map! = null()) then
                     map! = new TreeMap()
                fi
                keyValue$ =  key!.substring(pos(#Separator$ = key!,-1))
                
                rem let elements![] = key!.split(#Separator$)
                rem Add the key and value pair to the map
                rem map!.put(elements![1],translator!.getTranslation(key!))
                rem Add the key and value pair to the map
                map!.put(keyValue$,#Translator!.getTranslation(key!))
            fi
        wend
        methodret map!
    methodend

    rem /**
    rem * Method getRecordAsString:
    rem * return the toString for a record
    rem * @return BBjString disp$: the current result set
    rem */
    method public BBjString getRecordAsString(BBjNumber sel)

        #prepareResultSet(sel,sel)
        r! = #getResultSet().getItem(sel)
        methodret r!.getFieldAsString("VALUE")

    methodend
        
    rem /**
    rem  * Removes the global map from the GlobalNamespace if it exists.
    rem  */
    method public void clearCache()
          #Namespace!.removeValue(#AtbListMap$,err=*next)
    methodend
    
    method private BBjString invert(BBjString in$)
        for i=1 to len(in$)
            out$=out$+chr(255-asc(in$(i,1)))
        next
        methodret out$
    methodend

classend